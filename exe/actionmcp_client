#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup' # Ensure correct gem dependencies
require 'optparse'
require 'multi_json'
require 'actionmcp'

# Default options
options = {
  logging_level: "INFO"
}

# Parse command-line arguments
parser = OptionParser.new do |opts|
  opts.banner = "Usage: mcp_client ENDPOINT [options]"

  opts.on("-l", "--log-level LEVEL", "Set log level (DEBUG, INFO, WARN, ERROR)") do |l|
    options[:logging_level] = l.upcase
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end

# Extract first argument as endpoint
endpoint = ARGV.shift

# Parse remaining options
parser.parse!(ARGV)

if endpoint.nil?
  puts "Error: You must provide an MCP endpoint."
  puts parser
  exit 1
end

# Initialize and start the client
client = ActionMCP::Client.new(endpoint: endpoint)
client.logger.info("[MCP Client] Connecting to #{endpoint}...")
client.transport.on_message do |message|
  puts "Received: #{message.inspect}"
end

client.transport.on_error do |error|
  puts "Error: #{error}"
end

client.connect

Signal.trap("INT") do
  puts "\nReceived Ctrl+C. Disconnecting..."
  client.disconnect
  puts "MCP Client stopped."
  exit 0
end

# Handle interactive mode
puts "MCP Client connected to #{endpoint}."
puts "Enter MCP JSON-RPC commands or type 'exit' to quit."

loop do
  print "mcp> "
  input = gets.chomp
  break if input.downcase == "exit"

  begin
    request = MultiJson.load(input)
    client.send_request(request)
  rescue StandardError => e
    puts "Invalid JSON: #{e.message}"
  end
end

puts "Disconnecting..."
client.disconnect
puts "MCP Client stopped."
